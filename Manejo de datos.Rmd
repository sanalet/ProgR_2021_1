---
title: "Manejo de datos"
output: 
  html_notebook:
    toc: yes
    toc_float: yes
---

# Activar paquetes

```{r}
library(tidyverse)
```

# Limpiar espacio de trabajo

```{r}
rm(list = ls())
```

# Transformar bases de datos

¿Qué es tidy data i.e. datos limpios para análisis de datos?

Los datos limpios en este contexto cumplen 3 reglas:

1. Cada variable debe tener su propia columna. 
2. Cada observación debe tener su propia fila. 
3. Cada valor debe tener su propia celda.

```{r, echo=FALSE, eval=TRUE, out.width = "100%", fig.align = 'center'}
include_graphics("tidy.png")
```

¿Cuál de las siguientes bases de datos son "tidy"?
https://r4ds.had.co.nz/tidy-data.html#tidy-data-1

- No todos los datos están estructurados de esta manera. Hay dos problemas comunes:
    1. Una variable puede estar repartida en varias columnas. 
    2. Una observación puede estar repartida en varias filas. 
   
## Reorganizar de ancho a largo

1. Importen el conjunto de datos `gdp_growth_wide.csv`. Estos datos contienen la tasa de crecimiento del PIB para varios países entre 2009 y 2018. 

```{r}
gdp_growth_wide <- read_excel("Datos/gdp_growth_wide.xlsx")
```

2. Usen la función `head()` para ver el contenido del conjunto de datos.

```{r}

```

3. ¿Es un conjunto de datos limpio?

Cuando el conjunto de datos tiene el problema 1, usamos la función `pivot_longer()` del paquete tidyr para limpiarlo:

```{r, echo=FALSE, eval=TRUE, out.width = "100%", fig.align = 'center'}
include_graphics("gather.png")
```

La función `pivot_longer` tiene cuatro argumentos:
      
1. El conjunto de datos que se va a reformar o reorientar.
2. *cols*: Las columnas que se van a reformar o reorientar.
3. *names_to*: El nombre de la variable que se creará en la que van a quedar los valores que actualmente aparecen en los nombres de las columnas.
4. *values_to*: El nombre de la variable que se creará en la que van a quedar los valores que actualmente aparecen en las celdas de la base de datos.

En el caso del conjunto gdp_growth_wide la función operaría de la siguiente manera:

```{r}
gdp_growth_long <- pivot_longer(gdp_growth_wide, 
                          YR2009:YR2018, 
                          names_to = "YEAR", 
                          values_to = "GROWTH")
head(gdp_growth_long)
```

## Reorganizar de largo a ancho

1. Importen el conjunto de datos `gdp.csv`. Estos datos contienen el pib per capita y la tasa de crecimiento para un grupo de países entre 2009 y 2018.

```{r}
gdp <- read_csv("Datos/gdp.csv")
head(gdp)
```

2. Usen la función head para ver el contenido del conjunto de datos. 

```{r}

```

3. ¿Es un conjunto de datos limpio?

4. Cuando el conjunto de datos tiene el problema 2, usamos la función `pivot_wider()` del paquete tidyr para limpiarlo:

```{r, echo=FALSE, eval=TRUE, out.width = "100%", fig.align = 'center'}
include_graphics("spread.png")
```

La función `pivot_wider()` tiene 3 argumentos:
      
1. El conjunto de datos.
2. *names_from*: El nombre de la variable del conjunto actual en la que están los nombres de las variables.
3. *values_from*: El nombre de la variable del conjunto actual en la que están los valores que corresponden a cada variable.

En el caso del conjunto deptos la función operaría de la siguiente manera:

```{r}
gdp_long <- pivot_wider(gdp, 
                   names_from =`Series Name`, 
                   values_from =  valores)
head(gdp_long)
```

## Separar cadenas de carácteres

```{r}
gdp_growth_long <- separate(gdp_growth_long, YEAR, into = c("YR", "year"), sep = -4)
```


- Importen el archivo *lista.xlsx*. 

```{r}
library(readxl)
lista <- read_excel("Datos/Lista.xlsx")
```

- La función `separate` toma una cadena de caracteres (i.e. *string*) y la separa en dos o más columnas. Los argumentos de esta función son:
  - El data.frame en el cual se quiere hacer la separación. 
  - El nombre de la variable que se quiere separar. 
  - El nombre de las variables que se van a crear dentro de un vector.
  - El separador:
      - Por defecto es el primer carácter que no es ni número ni letra. 
      - Si se pone un número este refiere a la posición en la que se debe hacer la separación. Los valores positivos empiezan en en el valor más a la izquierda de la cadena. Los valores negativos empiezan en -1 en el valor más a la derecha de la cadena.
- Por ejemplo para separar los nombres en dos variables se emplearía la siguiente función:

```{r}
lista2 <- separate(data = lista, col = Nombres, into = c("Nombre1", "Nombre2"))
```

- Separen los apellidos en dos columnas distintas.

- Separen el correo electrónico en dos columnas distintas. La primera columna debe contener el nombre de usuario, y la segunda columna debe contener el resto de la dirección.

```{r}
lista2 <- separate(lista2, col = `Correo Electrónico`, into = c("usuario", "resto"), sep = "@")
```

```{r}
lista3 <- separate(lista, col = `Correo Electrónico`, into = c("usuario", "resto"), sep = 10)
```

```{r}
lista4 <- separate(lista, col = `Correo Electrónico`, into = c("usuario", "resto"), sep = -10)
```

## Unir cadenas de carácteres

- La función `unite` permite unir dos cadenas de carácteres en una sola variable. Los argumentos de esta función son:
  - El data.frame en el cual se quiere hacer la separación. 
  - El nombre de la variable que se creará. 
  - El nombre de las variables que se van a unir. 
  - La manera como se van a separar los valores. Por defecto, el separador es: _

- Por ejemplo, en el archivo lista, para unir nombres y apellidos en una variable que se llame nombre_completo, se ejecutaría la siguiente función: 


```{r}
lista3 <- unite(data = lista, col = nombre_completo, Nombres, Apellidos, sep = " ")
```

- Vuelvan a unir el correo electrónico en una variable que se llame Correo. 

```{r}

```

# Manejo de datos faltantes:



# Unir bases de datos

Dos casos en los que es común unir bases de datos:

* En un mismo archivo, distintas bases de datos tienen variables para los mismos individuos. Por ejemplo, Encuesta Multipropósito de Bogotá o Panel Municipal CEDE.

* Una base de datos tienen información para individuos, y otra u otras tienen información para unidades de agrupación dentro de las que se encuentran esos individuos. Por ejemplo: estudiantes-colegios, colegios-municipios, individuos-hogares, individuos-firmas, etc.

**Agregar columnas a una base de datos:**

En esos casos RStudio y el paquete dplyr proveen distintas funciones, según sea el caso y el objetivo de la unión.

Estas funciones cruzan las observaciones según una o varias variables que sirven de "llave" e identifica observaciones en las dos bases de datos, y luego copia las variables de una base a la otra. Hay varias opciones:

## *Inner Join:*

Solamente une las observaciones que se encuentran en las dos bases de datos:
![](inner.png)

## *Outer Join:*

- **Left Join:** Mantiene todas las observaciones de la primera base de datos.
- **Right Join:** Mantiene todas las observaciones de la segunda base de datos base de datos.
- **Full Join** Mantiene todas las observaciones de las dos bases de datos, así no hayan cruces.

**Agregar columnas a una base de datos:**

*Outer Join:*

```{r, out.height="70%", eval=TRUE, echo=FALSE, fig.align="center"}
library(knitr)
include_graphics("outer.png")
```

1. Cargue a R las bases de datos del panel municipal con los siguientes nombres, según corresponda:
    + general
    + gobierno
    
```{r}
general <- read_stata("Datos/Panel Municipal/PANEL_CARACTERISTICAS_GENERALES(2019).dta")
gobierno <- read_stata("Datos/Panel Municipal/PANEL_BUEN_GOBIERNO(2019).dta")
```
  
2. Revise el contenido de una de las bases de datos. ¿Cuáles serían la(s) llave(s) para unir estas bases de datos?

3. Use inner_join para unir la base general y conflicto. LLame a esta nueva base de datos panel_municipal, asi:

```{r}
unique(general$ano)
unique(gobierno$ano)
```


```{r}
panel <- inner_join(general, gobierno, by = c("codmpio", "ano"))
```

```{r}
panel <- left_join(general, gobierno, by = c("codmpio", "ano"))
```

```{r}
panel <- right_join(general, gobierno, by = c("codmpio", "ano"))
tail(panel)
```

```{r}
panel <- full_join(general, gobierno, by = c("codmpio", "ano"))
```


4. A la base anterior, una el panel de salud:

```{r}
salud <- read_stata("Datos/Panel Municipal/PANEL_SALUD_Y_SERVICIOS.dta")
unique(salud$ano)
```
```{r}
panel <- inner_join(panel, salud, by = c("codmpio", "ano"))
```



- El paquete tidyr también contiene funciones para tratar los valores faltantes (i.e. NA). 
- Estas funciones principlamente permiten (1) eliminar las observaciones con valores faltantes (`drop_na`), (2) completar las observaciones con valores faltantes con los valores de observaciones previas o posteriores (`fill`), y (3) reemplazar los valores faltantes con otro valor (`replace_na`).
- **Estas funciones deben usarse con cuidado**. 
- Antes de eliminar, completar o reemplazar valores faltantes es necesario conocer la estructura de los datos, entender porqué puede haber valores faltantes, y qué tipo de información se perdería si, por ejemplo, se descartan todas las observaciones que tienen datos faltantes. 

### Borrar observaciones con datos faltantes:

La función `drop_na` elimina las observaciones con valores faltantes en las columnas que se indiquen. Si no se indica ninguna columna, entonces la función borra las observaciones con valores faltantes en todas las columnas:

- Importen la base de datos: saber11_2019.csv

```{r}
saber11_2019 <- read_delim("Datos/saber11_2019.csv", delim = ";")
```


- Noten que actualmente la base tiene 54621 observaciones. 
- Si aplico `drop_na` sin indicar ninguna columna se borran todas las observaciones pues es posible que todas las observaciones tengan algun valor faltante en alguna de las variables (P. Ej. ESTU_ETNIA)

```{r}
saber_sin_na <- drop_na(saber11_2019)
```

- Para solamente borrar aquellas observaciones que tengan valores faltantes en las variables FAMI_ESTRATOVIVIENDA, FAMI_EDUCACIONMADRE y FAMI_EDUCACIONPADRE se debería usar la siguiente función:

```{r}
saber2 <- drop_na(saber11_2019, FAMI_ESTRATOVIVIENDA, FAMI_EDUCACIONMADRE, FAMI_EDUCACIONPADRE)
```

¿Cuántas observaciones se eliminan en este caso?

### Rellenar observaciones con datos faltantes: 

La función `fill` rellena los valores faltantes con valores completos que estén antes o despúes de los faltantes.

- Importen la base *PANEL_CARACTERISTICAS_GENERALES.dta*.
- Fíjense que la variable nbi no tiene información para todos los años. En los años en los que no hay información actualmente hay datos faltantes.
- Para sustituir esos valores faltantes por el último valor completo se usaría la función `fill` de la siguiente manera:

```{r}
library(haven)
general <- read_stata("Datos/Panel Municipal/PANEL_CARACTERISTICAS_GENERALES(2019).dta")
general <- fill(general, pobreza)
```

### Reemplazar observaciones faltantes

La función `replace_na` reemplaza los valores faltantes con los valores que se indiquen dentro de la función. Por ejemplo, para reemplazar los valores faltantes de la variable ESTU_ETNIA en la base de datos de saber11 2018, se usaría la siguiente función:

```{r}
saber11_2019 <- replace_na(data = saber11_2019, replace = list(ESTU_ETNIA = "Sin reporte"))
```

Dentro de la lista se pueden ingresar más variables. 

# Manejo de variables y observaciones 

El paquete *dplyr* provee varias funciones para la manipulación de datos:

Función      | Propósito
------------ | ----------
`select()`   | Selecciona variables
`rename()`   | Renombra variables
`filter()`   | Filtra observaciones
`mutate()`   | Crea variables
`summarize()`| Resume variables (P. Ej. Estadísticas descriptivas)
`group_by()` | Crea grupos de observaciones, para luego usar `mutate()` o `summarize()`
`arrange()`  | Ordena observaciones.

La estructura de todas estas funciones es similar:

- El primer argumento es la base de datos que se quiere modificar.

- Los argumentos siguientes reflejan lo que se quiere hacer con la base de datos.

- El resultado es una base de datos modificada.

## Filtrar observaciones: `filter()`

- `filter()` sirve para crear un subconjunto de observaciones con base en sus valores.
- El primer argumento es la base que se quiere filtrar.
- Los argumentos siguientes son las expresiones que filtran las observaciones.
- **El primer argumento no es necesario si se usa el operador *pipe*: `%>%`**
- Carguen la base de datos "saber11_2019.csv"
- Para filtrar los estudiantes que asisten a colegios públicos se usaría la siguiente función:

```{r}
oficial <- filter(saber11_2019,
                  COLE_NATURALEZA == "OFICIAL")
```

- Ó:

```{r}
oficial <- saber11_2019 %>%
  filter(COLE_NATURALEZA == "OFICIAL") 
```

El atajo para el *pipe* es **Shift + Control + M**

- Filtrar por más de una condición:

```{r}
estrato_colegio <- saber11_2019 %>% filter(FAMI_ESTRATOVIVIENDA == "Estrato 1", COLE_NATURALEZA == "OFICIAL")

```

Otro ejemplo: 

```{r}
estrato_colegio <- saber11_2019 %>% 
  filter(FAMI_ESTRATOVIVIENDA %in% c("Estrato 1", "Estrato 2"), 
         COLE_NATURALEZA == "OFICIAL")
```

- Filtrar variables cuantitativas entre dos valores

```{r}
summary(saber11_2019$PUNT_GLOBAL)
```

```{r}
puntajes_medio <- saber11_2019 %>% 
  filter(PUNT_GLOBAL >= 207 & PUNT_GLOBAL <= 282)
```

```{r}
summary(puntajes_medio$PUNT_GLOBAL)
```

Otra manera de hacerlo:

```{r}
puntajes_medio_2 <- saber11_2019 %>% 
  filter(between(PUNT_GLOBAL, 207, 282))
```

¿Cómo se haría esto en base R?

```{r}
library(help = dplyr)
vignette("dplyr")
vignette("base")
```

## Manipulación de datos en R: `select()`

- `select()` sirve para crear un una base de datos con un subconjunto de variables.
- El primer argumento es la base que contiene todas las variables.
- Los argumentos siguientes dan instrucciones para seleccionar las bases de datos.

### Maneras de seleccionar las variables:

- Nombrándolas una por una
- Poniéndolas en un vector
- Con una secuencia si son consecutivas.
- Usando las siguientes funciones:
    - `starts_with()`
    - `ends_with()`
    - `contains()`
    - `num_range()`
    - `everything()`
    
```{r}
identificacion <- saber11_2019 %>% 
  select(ESTU_TIPODOCUMENTO, ESTU_NACIONALIDAD, ESTU_GENERO)
```

```{r}
variables <- c("ESTU_TIPODOCUMENTO", "ESTU_NACIONALIDAD", "ESTU_GENERO")
identificacion2 <- saber11_2019 %>% 
  select(all_of(variables))
```

```{r}
variables2 <- c("ESTU_TIPODOCUMENTO", "ESTU_NACIONALIDAD", "ESTU_GENERO", "P6020")
identificacion3 <- saber11_2019 %>% 
  select(any_of(variables2))
```

```{r}
básicos <- saber11_2019 %>% 
  select(ESTU_TIPODOCUMENTO:ESTU_COD_RESIDE_DEPTO)
```
    
```{r}
puntajes <- saber11_2019 %>% 
  select(starts_with("PUNT"))
```

```{r}
ingles <- saber11_2019 %>% 
  select(ends_with("INGLES"))
```

```{r}
nse <- saber11_2019 %>% 
  select(contains("NSE_"))
```

```{r}
saber11_2019 <- saber11_2019 %>% 
  select(-contains("NSE_"))
```

`everything()`sirve para reorganizar variables, aunque `relocate`, en la versión más reciente de dplyr, cumple esa función de mejor manera:

```{r}
saber11_2019 <- saber11_2019 %>% 
  select(starts_with("PUNT"), everything())

saber11_2019 <- saber11_2019 %>% 
  relocate(starts_with("PUNT"))

saber11_2019 <- saber11_2019 %>% 
  relocate(contains("NSE_"), .after = PUNT_INGLES)
```

- `rename()` permite cambiar el nombre de variables, dejando el resto de variables intacto.

```{r}
saber11_2019 <- saber11_2019 %>% 
  rename(tipo_colegio = COLE_CARACTER)
saber11_2019 <-  rename(saber11_2019, tipo_colegio = COLE_CARACTER)
```

### Función num_range dentro de `select()`

*num_range()* permite seleccionar variables que contienen números en su nombre, indicando un rango numérico.

- Carguen la base de datos *Area_Caracteristicas_generales_Personas.csv*.
- Con base en esta base de datos, creen una base de datos que se llame variables y contenga las variables quE están entre P6010 y P6100.

```{r}
personas <- read_delim("Datos/GEIH Diciembre 2019.csv/Área - Características generales (Personas).csv", delim = "|")
```


```{r}
variables <- personas %>% 
  select(num_range("P", 6010:6100))
```

## Manipulación de datos en R: `mutate()`

- `mutate()` sirve para crear o transformar variables existentes.
- Las variables siempre son agregadas al final del conjunto actual.
- En la creación de variables se puede usar:
    - Operaciones aritméticas.
    - Logarítmos.
    - lags y leads.
    - Comparaciones lógicas.
    - Rankings, entre otros.
- También se pueden reconvertir variables, por ejemplo a fecha o a factor, y se pueden crear constantes.
    
```{r}
library(lubridate)
class(saber11_2019$FAMI_ESTRATOVIVIENDA)
saber11_2019 <- saber11_2019 %>% 
  mutate(semestre = "Segundo Semestre", 
         year = 2019, 
         mate_lect = PUNT_MATEMATICAS + PUNT_LECTURA_CRITICA, 
         mate_2 = PUNT_MATEMATICAS ^ 2, 
         log_global = log(PUNT_GLOBAL),
         estrato = factor(FAMI_ESTRATOVIVIENDA), 
         nacimiento = dmy(ESTU_FECHANACIMIENTO)) %>% 
  relocate(nacimiento, semestre, year, mate_lect, mate_2, log_global)
class(saber11_2019$estrato)
saber11_2019 <- relocate(saber11_2019, semestre)
saber11_2019 <- saber11_2019 %>% relocate(semestre)

head(saber11_2019)
```
    

### Lags y leads en `mutate()`

- Carguen la base de datos *Tasa_de_Cambio_Representativa_del__Mercado_-Historico.csv* y asegúrense que R entienda las fechas de manera correcta.
- Usen `arrange` para organizar las fechas de la más reciente a la más antigua.
- Creen tres variables en esta base de datos:
  - Un rezago (t-1) de la variable VALOR.
  - Dos rezagos (t-2) de la variable VALOR.
  - El valor del periodo siguiente (t+1) de la misma variable

```{r}
trm <- read_csv("Datos/Tasa_de_Cambio_Representativa_del__Mercado_-Historico.csv")
trm <- trm %>% 
  mutate(VIGENCIAHASTA = dmy(VIGENCIAHASTA)) %>% 
  arrange(VIGENCIAHASTA)
```
```{r}
trm <- trm %>% 
  arrange(desc(VIGENCIAHASTA))
trm <- trm %>%  
  arrange(VIGENCIAHASTA)

trm <- trm %>% 
  mutate(lag_1 = lag(VALOR), 
         lag_2 = lag(VALOR, n=2), 
         lead_1 = lead(VALOR))
```


### Funciones `if_else`, `recode` y `case_when` en `mutate()`

- `recode` se usa cuando los cambios que se planean hacer son *uno a uno*, dentro de las categorías de la variable.

- Estas tres funciones son útiles para crear variables dummy o binarias, para crear variables categóricas con base en variables cuantitativas, o para modificar variables categóricas.

- `if_else` incluye una condición, y asigna un valor a la variable que se crea o modifica si la condición se cumple, y otro valor si no se cumple.

    - Es necesario usar esta función con cuidado **particularmente con variables que tengan datos faltantes**, porque el resultado puede ser que se sustiya con un valor lo que debería ser un valor faltante.

- `case_when` se usa cuando los criterios para la creación o modificación de las categorías de la variable que se crea o modifica son más complejos. Por ejemplo, cuando se quiere crear una variable categórica con base en los valores de una variable cuantitativa o en varias categorías de una variable categórica.

- Use la función `recode` para crear una variable que se llame **privado** que sea igual a 1 para los estudiantes que estudian en colegios privados y 0 para los estudiantes que estudian en colegios públicos Use la variable `COLE_NATURALEZA`.

```{r}
table(saber11_2019$COLE_NATURALEZA)
saber11_2019 <- saber11_2019 %>% 
  mutate(privado = recode(COLE_NATURALEZA, "NO OFICIAL" = 1, "OFICIAL" = 0)) %>% 
  relocate(privado, COLE_NATURALEZA)
head(saber11_2019, 10 )
```

- Use la función `if_else` para crear una variable que se llame **bogota** que sea igual a 1 para los estudiantes que residen en Bogotá y 0 para quienes residen en cualquier otro municipio. Use la variable `ESTU_MCPIO_RESIDE`.

```{r}
saber11_2019 <- saber11_2019 %>% 
  mutate(bogota = if_else(ESTU_MCPIO_RESIDE == "BOGOTÁ D.C.", 1, 0)) %>% relocate(bogota, ESTU_MCPIO_RESIDE)
head(saber11_2019, 10)
```
- Use la función `case_when` para crear una variable que se llame **estrato** que tenga tres categorías: *bajo* para los estudiantes de estratos 1 y 2, *medio* para los estudiantes de estratos 3 y 4, y *alto* para los estudiantes de estratos 5 y 6. Use la variable `FAMI_ESTRATOVIVIENDA`.

```{r}
table(saber11_2019$FAMI_ESTRATOVIVIENDA)

saber11_2019 <- saber11_2019 %>% 
  mutate(estrato = case_when(FAMI_ESTRATOVIVIENDA %in% c("Estrato 1", "Estrato 2") ~ "bajo",
                             FAMI_ESTRATOVIVIENDA %in% c("Estrato 3", "Estrato 4") ~ "medio", 
                             FAMI_ESTRATOVIVIENDA %in% c("Estrato 5", "Estrato 6") ~ "alto", 
                             FAMI_ESTRATOVIVIENDA == "Sin Estrato" ~ "Sin estrato")) %>% 
  relocate(estrato, FAMI_ESTRATOVIVIENDA)
head(saber11_2019, n = 10)

table(saber11_2019$estrato, saber11_2019$FAMI_ESTRATOVIVIENDA, useNA = "ifany")
```

## Manipulación de datos en R: `summarize()`

- `summarize()` collapsa una base de datos en una sola fila que contiene medidas de resumen de la base de datos.

- Las medidas de resumen pueden incluir:

  - Medidas de tendencia central.
  - Medidas de dispersión.
  - Medidas de posición.
  - Frecuencias.
  - Frecuencias y proporciones para valores lógicos, entre otros.

```{r}
resumen <- saber11_2019 %>% summarize(MEDIA = mean(PUNT_GLOBAL, na.rm = TRUE), 
                                      DESVIACION = sd(PUNT_GLOBAL, na.rm = TRUE))
```

- Cuando se usa con `group_by()` crea medidas de resumen para los grupos incluidos en `group_by()`.

```{r}
resumen_natu <- saber11_2019 %>% 
  group_by(COLE_NATURALEZA) %>% 
  summarize(MEDIA = mean(PUNT_GLOBAL, na.rm = TRUE), 
                                      DESVIACION = sd(PUNT_GLOBAL, na.rm = TRUE))

resumen_estratos <- saber11_2019 %>% 
  group_by(FAMI_ESTRATOVIVIENDA) %>% 
  summarize(MEDIA = mean(PUNT_GLOBAL, na.rm = TRUE), 
                                      DESVIACION = sd(PUNT_GLOBAL, na.rm = TRUE))

resumen_DEPTOS <- saber11_2019 %>% 
  group_by(COLE_DEPTO_UBICACION) %>% 
  summarize(MEDIA = mean(PUNT_GLOBAL, na.rm = TRUE), 
                                      DESVIACION = sd(PUNT_GLOBAL, na.rm = TRUE)) %>% 
  arrange(desc(MEDIA))
```
Cuando se usa con `rowwise()` crea medidas por fila para las  para las variables incluidas en `rowwise()`.

```{r}
library(tidyverse)
minimo <- saber11_2019 %>% rowwise() %>% 
  summarise(mínimo = min(c(PUNT_C_NATURALES, PUNT_LECTURA_CRITICA, 
                           PUNT_MATEMATICAS, PUNT_SOCIALES_CIUDADANAS, PUNT_INGLES)), 
            media = mean(c(PUNT_C_NATURALES, PUNT_LECTURA_CRITICA, 
                           PUNT_MATEMATICAS, PUNT_SOCIALES_CIUDADANAS, PUNT_INGLES)))
```

- `group_by()` y `rowwise()` también se pueden usar para crear variables con `mutate()`.

```{r}
saber11_2019 <- saber11_2019 %>% 
  group_by(COLE_DEPTO_UBICACION) %>% 
  mutate(media_depto = mean(PUNT_GLOBAL, na.rm = TRUE)) %>% 
  relocate(media_depto)

```

Usen rowwise y mutate para crear una variable que contenga el promedio de los puntajes anteriores.

```{r}
saber11_2019 <- saber11_2019 %>% 
  rowwise() %>% 
  mutate(promedio = mean(c(PUNT_C_NATURALES, PUNT_LECTURA_CRITICA, 
                           PUNT_MATEMATICAS, PUNT_SOCIALES_CIUDADANAS, PUNT_INGLES))) %>% 
  relocate(promedio)
head(saber11_2019, 10)
```

- `across` permite usar summarise para un conjunto de variables. Por ejemplo, usemos across para calcular el promedio de los puntajes. 

```{r}
puntajes <- saber11_2019 %>% 
  group_by(FAMI_ESTRATOVIVIENDA) %>% 
  summarize(across(starts_with("PUNT"), ~mean(.x, na.rm = TRUE)))

puntajes <- saber11_2019 %>% 
  group_by(FAMI_ESTRATOVIVIENDA) %>% 
  summarize(across(starts_with("PUNT"), list(media = mean, desviacion = sd)))
```

```{r}
puntajes2 <- saber11_2019 %>% 
  select(starts_with("PUNT"), ESTU_DEPTO_RESIDE) %>% 
  summarize(across(where(is.numeric), ~min(.x, na.rm = TRUE)))
```

## Función `count()`

`count()` es una buena opción para calcular frecuencias absolutas.

Por ejemplo, para contar cuántos estudiantes hay en cada departamento podría usar la siguiente función:

```{r}
numero_estu_depto <- saber11_2019 %>%
  count(ESTU_DEPTO_RESIDE, sort = TRUE) 

```

Creen una base que contenga el número de estudiantes para cada estrato y cada nivel educativo de la mamá (en la misma base).

https://dplyr.tidyverse.org/reference/index.html

¿Cómo se haría todo esto en base R?:
```{r}
library(help = "dplyr")
vignette("dplyr")
vignette("base")
```

# Manejo de Factores

## Factors: paquete *forcats*

- Recuerden que en R, los factores son variables categóricas. 
- En ocasiones, es necesario modificar o recodificar los valores de esas variables, o colapsar los valores de las variables en otras categorías. 
- En esos casos, podríamos usar if, case_when o recode, pero el paquete *forcats* tiene unas funciones que permiten hacer estas tareas de manera más sencilla tratándose de variables categóricas. 

## ¿Cómo convertir una variable a factor?

- Una alternativa que hemos usado es `parse_factor`. Sin embargo, esta no es tan útil cuando el cambio se quiere hacer para varias variables. 
- Lo mejor es usar `mutate` con la función `factor`:
- Por ejemplo, para convertir `FAMI_ESTRATOVIVIENDA` en un factor usaríamos la siguientes función:

```{r}
saber11_2019 <- saber11_2019 %>% 
  mutate(FAMI_ESTRATOVIVIENDA = 
           factor(FAMI_ESTRATOVIVIENDA))

class(saber11_2019$FAMI_ESTRATOVIVIENDA)
```

Conviertan en factor la variable FAMI_EDUCACIONMADRE.

## Funciones para cambiar las categorías:

- `fct_recode`: Recodificar las categorías.

```{r}
library(forcats)
saber11_2019 <- saber11_2019 %>% 
  mutate(mujer = fct_recode(ESTU_GENERO, 
           "Mujer" = "F",
           "Hombre" = "M"))
```

## Funciones para cambiar las categorías:  

- `fct_collapse`: Colapsar variables de una variable categórica en otras categorías:

```{r}
saber11_2019 <- saber11_2019 %>% 
  mutate(nivel_educ = fct_collapse(FAMI_EDUCACIONMADRE, 
  "No bachiller" = c("Ninguno", "Primaria incompleta", 
                     "Primaria completa", 
                     "Secundaria (Bachillerato) incompleta"),
  "Bachiller" = c("Secundaria (Bachillerato) completa", 
                  "Técnica o tecnológica incompleta", 
                  "Técnica o tecnológica completa", 
                  "Educación profesional incompleta" ),
  "Universitario" = c("Educación profesional completa", 
                      "Postgrado")))
table(8)
```

Colapsen los estratos en tres categorías: bajo, medio, y alto. 

## Funciones para cambiar las categorías:  

- `fct_lump`: Colapsar los valores menos frecuentes en una sola categoría:

```{r}
saber11_2019 <- saber11_2019 %>% 
  mutate(estrato = fct_lump(FAMI_ESTRATOVIVIENDA, n = 2, other_level = "Otros estratos"))
fct_count(saber11_2019$estrato)
```

- `fct_other`: Crear una categoría de otros:
```{r}
table(saber11_2019$ESTU_NACIONALIDAD)
saber11_2019 <- saber11_2019 %>% 
  mutate(nacionalidad = 
           fct_other(saber11_2019$ESTU_NACIONALIDAD,
                     keep = c("COLOMBIA", "VENEZUELA"), other_level = "Otros países"))
fct_count(saber11_2019$nacionalidad)
```

## Funciones para resumir factores

- `fct_count`: muestra las frecuencias absolutas de una variable categórica.
```{r}
fct_count(saber11_2019$FAMI_EDUCACIONMADRE)
```

- fct_unique: identifica los valores únicos de las categorías de un factor.
```{r}
fct_unique(saber11_2019$ESTU_NACIONALIDAD)
```

## Funciones para reordenar factores:

- `fct_relevel`: Cambiar el orden de las categorías manualmente.

```{r}
saber11_2019 <- saber11_2019 %>% 
  mutate(estrato = fct_relevel(
    saber11_2019$FAMI_ESTRATOVIVIENDA, 
    c("Estrato 6", "Estrato 1", "Estrato 2",
      "Estrato 3", "Estrato 4", 
      "Estrato 5")))
fct_count(saber11_2019$estrato)
```

- `fct_infreq`: organiza según la frecuencia con la que aparecen en los datos.
```{r}
fct_count(fct_infreq(saber11_2019$FAMI_EDUCACIONMADRE))
```

- fct_rev: invierte la organización de un factor:

```{r}
fct_count(
  fct_rev(fct_infreq(saber11_2019$FAMI_EDUCACIONMADRE)))
```

# Manipulación de Fechas 

## Manipulación de Fechas

**Crear fechas/tiempos:**

- Como hemos visto, usualmente creamos fechas de un texto. Para esto hemos usado las fuciones `col_date` y `col_datetime`. 

- El paquete `lubridate` contiene algunas funciones que facilitan este proceso (Ver hoja de referencia). 

- Por ejemplo, para crear una fecha con base en el texto "17-9-2019" podemos usar la siguiente función:

```{r}
fecha <- dmy("17-9-2019")
fecha
class(fecha)
```

- Usando `mutate` y una función de `lubridate` conviertan la variable `ESTU_FECHANACIMIENTO`, que actualmente es "character", a "date". 

## Manipulación de Fechas

**Crear fechas/tiempos:**

También podría ser necesario construir una fecha con base en los componentes.

Por ejemplo, si tuvieran los siguientes componentes:

```{r}
día <- "17"
mes <- "9"
año <- "2019"
```

Podría crearse una fecha usando la siguiente función:

```{r}
library(lubridate)
fecha2 <- make_date(año, mes, día)
fecha2
class(fecha2)
```

## Manipulación de Fechas

**Obtener y fijar los componentes de las fechas**

- `date()`, `year()`, `month()`, `day()`, `wday()` (día de la semana), `week()` y `quarter()` (para el trimestre), entre otras permiten extraer los componentes (Ver otras funciones en hoja de referencia)

```{r}
ahora <- now()
ahora

date(ahora)
year(ahora)
wday(ahora, week_start = 1, label = TRUE)
quarter(ahora)
```

Creen una variable que contenga el mes de nacimiento de las personas incluidas en la muestra.

## Manipulación de Fechas
**Aproximar fechas**

- Las funciones `floor_date()`, `round_date()` y `ceiling_date()` redondea las fechas hacía abajo, a la más cercana o hacía arriba, respectivamente. Las unidades están dadas por el argumento `unit = `

```{r}
hoy <- today()
AYER <- dmy("31/08/2020")
floor_date(hoy, unit = "month")
floor_date(AYER, unit = "month")
ceiling_date(hoy, unit = "month")
round_date(hoy, unit = "month")
round_date(AYER, unit = "month")
```

## Manipulación de Fechas

**"Espacios" de tiempo**

Hay tres tipos de "espacios" de tiempo:

- *Durations*: representan un número exacto de segundos (i.e. "tiempo físico") 
- *Periods*: Representan unidades "humanas" como semanas o meses. 
- *Intervals*: Representan un punto inicial y un punto final. 

## Manipulación de Fechas

***Durations***

Representan el tiempo en segundos:

```{r}
library(lubridate)
dyears(1)
dweeks(1)
ddays(1)
dhours(1)
dminutes(1)
duration(1, unit ="months")
# Ver otras funciones en hoja de referencia.
```
Cada una de estas funciones se hubiera podido replicar con la función `duration(1, unit = ___ )`

¿Qué pasa si a la fecha de hoy le restan `dyears(2)`?

```{r}
hoy <- today()
leap_year(hoy)
hoy + dyears(2)
dmy("1-3-2020") - dmonths(1)
dmy("27-02-2020") + dmonths(5)
```


## Manipulación de Fechas

***Periods***

El problema anterior lo resuelven los periodos. Estos representan el tiempo en unidades "humanas":

```{r}
years(1)
weeks(1)
days(2)
hours(1)
minutes(1)
# Ver otras funciones en hoja de referencia.
```

¿Qué pasa si a la fecha de hoy le resta `years(2)`?

```{r}
dmy("1-3-2020") - months(1)
dmy("27-02-2020") + months(5)
hoy + weeks(1)
```


## Manipulación de Fechas
***Intervals***

Los intervalos son objetos con una fecha de inicio y una final:

```{r}
próximo_año <- interval(today(), today() + dyears(1))
próximo_año
```

¿Cuántos años hay en este intervalo?

```{r}
próximo_año/dyears(1)
próximo_año/dmonths(1)
próximo_año/dweeks(1)
```
```{r}
febrero <- interval(dmy("1-2-2020"), dmy("1-3-2020"))
febrero/dmonths(1)
febrero/ddays(1)
febrero/months(1)
febrero/days(1)
```


Cree una variable que contenga la edad en años de las personas incluidas en la base de saber 11 2019 - 2.

```{r}
saber11_2019 <- saber11_2019 %>% 
  mutate(ESTU_FECHANACIMIENTO = dmy(ESTU_FECHANACIMIENTO), 
        EDAD = interval(ESTU_FECHANACIMIENTO, dmy("20-08-2019"))/years(1))

intervalo <- floor(interval(saber11_2019$ESTU_FECHANACIMIENTO, dmy("20-08-2019"))/years(1))
intervalo
mean(intervalo)

saber11_2019 <- saber11_2019 %>% 
  relocate(EDAD, ESTU_FECHANACIMIENTO)
head(saber11_2019)
```
 


# Manipulación de cadenas de caracteres

## Funciones para explorar cadenas de caracteres

```{r}

palabras <- c("Fundamentos", "de", "Programación", "Economía", "Pregrado", "Semestre 7", "2020-2")
palabras
```

```{r}
str_detect(palabras, "ón")
```

```{r}
str_detect(palabras, "do")
```

```{r}
str_detect(palabras, "^P")
str_detect(palabras, "e$")
```

```{r}
str_detect(palabras, "[:digit:]")
str_which(palabras, "[:digit:]")
str_count(palabras, "[:digit:]")
str_locate(palabras, "[:digit:]")

```
```{r}
str_detect(palabras, "[:digit:]+")

str_locate(palabras, "[:digit:]{4}")
str_locate(palabras, "[:digit:]+")
str_locate_all(palabras, "[:digit:]+")

```

## Funciones para extraer contenido 

```{r}
palabras
str_sub(palabras,1, 3)
str_sub(palabras, -3, -1)
str_extract(palabras, "[0-9]")
str_extract(palabras, "[0-9]{4}")
str_extract(palabras, "[0-9]+")
str_extract_all(palabras, "[0-9]")
str_extract_all(palabras, "[0-9]+")
str_extract_all(palabras, "[0-9]{1,}")
str_extract_all(palabras, "[0-9]{1,4}")
str_match(palabras, "[0-9]")
str_match_all(palabras, "[0-9]")
str_match_all(palabras, "[0-9]+")

str_subset(palabras, "[:digit:]")
str_subset(palabras, "[:digit:]{4}")

```
## Funciones para reemplazar datos

```{r}
str_replace(palabras, "[:digit:]", "0")
str_replace_all(palabras, "[:digit:]", "0")

str_replace_all(palabras, "[:digit:]{4}", "2019")
str_replace_all(palabras, "2020", "2019")

```
```{r}
str_to_lower(palabras)
str_to_upper(palabras)

```
```{r}
str_c(palabras, collapse = "")
palabras2 <- str_c(palabras, collapse = " ")
palabras2
```
```{r}
palabras3 <- str_to_lower(palabras2)
palabras3
str_to_title(palabras3)
str_to_sentence(palabras2)
```


```{r}
respuestas <- rep(c("Sí", "No", "No", "Sí", "Sí"), 10)
respuestas_sin_tilde <- str_replace(respuestas, "í", "i")
respuestas_sin_tilde
```

```{r}
san <- saber11_2019 %>% 
  filter(str_detect(ESTU_MCPIO_RESIDE, "^SAN "))
unique(san$ESTU_MCPIO_RESIDE)

saber11_2019 <- saber11_2019 %>% 
  mutate(SAN = str_extract(ESTU_MCPIO_RESIDE, "^SAN "), 
         ESTU_MCPIO_RESIDE = str_to_title(ESTU_MCPIO_RESIDE)) %>% 
  relocate(SAN, ESTU_MCPIO_RESIDE)
```



